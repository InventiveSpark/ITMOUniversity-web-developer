/* Функция buildNames() получает список имен людей и имя класса, который 
   выступает в роли селектора родительского элемента. Возвращает true, если 
   удалось найти родительский элемент, который является упорядоченным или 
   неупорядоченным списком, и добавить в него заданные имена (каждое имя 
   в отдельный элемент <li>). Возвращает false, если родительский элемент 
   не был найден. */
function buildNames(namesList, selector) {
    /* Объявление переменной логического типа, которую будет возвращать функция.
       По умолчанию функция возвратит false (родительский элемент не найден): */
    let result = false;
    /* Для того, чтобы получить доступ к тегу <ul> или <ol>, производится 
       обращение к значению его класса selector.
       DOM-метод getElementsByClassName() используется для получения элементов
       по имени класса. Возвращает массивоподобный (итерируемый) объект всех 
       дочерних элементов, принадлежащих классу (так как один класс может 
       содержать множество элементов). 
       В случае вызова по отношению к объекту "document", поиск происходит 
       по всему документу, включая корневой элемент. 
       Вызывать getElementsByClassName() можно также применительно к любому 
       элементу: возвращены будут лишь те элементы, которые являются потомками
       указанного корневого элемента и имеют при этом заданные классы. 
       Метод возвращает объект HTMLCollection (коллекцию), который является 
       массивоподобным объектом, доступным только для чтения. У него есть 
       свойство length. Кроме того, его можно индексировать (но только для 
       чтения, а не для записи), как настоящий массив.
       Объявление константы, ссылающейся на коллекцию элементов (компонентов 
       формы), принадлежащих классу selector: */
    const PARENTS = document.getElementsByClassName(selector);
    /* Для каждого из элементов коллекции, принадлежащих классу selector, */
    for (let parent of PARENTS) { // Можно использовать также for (let i = 0; i < PARENTS.length; i++) {...PARENTS[i]...}
        /* проверяется, является ли он упорядоченным (тег <ol>) или 
           неупорядоченным списком (тег <ul>). Если является, */
        if (parent.tagName === "UL" || parent.tagName === "OL") {
            /* то для каждого имени из заданного списка */
            namesList.forEach(name => {
                // создаётся элемент разметки <li>,
                let li = document.createElement('li');
                // в параметр innerText которого добавляется имя из списка.
                li.innerText = name;
                /* Затем сформированный элемент <li> добавляется к элементу 
                   родительского тега <ul> или <ol> с классом selector.
                   Метод Element.append() вставляет узлы или строки с текстом 
                   в конец Element. Строки с текстом вставляются как текстовое
                   содержимое. Метод Element.append() не возвращает ничего, 
                   поэтому нет дополнительных возможностей проконтролировать 
                   успешность добавления: */
                parent.append(li);
            });
            /* Родительский элемент найден и в него добавлены имена из списка,
               поэтому функция возвратит true: */
            result = true;
            /* После того, как элементы списка c именами людей были добавлены 
               в первый найденный упорядоченный или неупорядоченный список, 
               принадлежащий классу selector, происходит выход из цикла. 
               В другие списки с классом selector имена добавляться не будут: */
            break;
        }
    }
    /* Функция возвращает переменную логического типа, в которой отражён 
       результат её работы: */
    return result;
}

console.log("Selector='list'. buildNames() return status code is:",
    buildNames(['Андрей', 'Дима', 'Нина', 'Света', 'Стас'], 'list'));


